---
title: Codewars001 - 匹配整除N的二进制字符串的正则表达式
permalink: /codewars001
---

[原题链接](https://www.codewars.com/kata/5993c1d917bc97d05d000068)
# 题目
- 创建一个函数，输入正整数`n`（`1<=n<=18`），返回一个正则表达式字符串，匹配整除`n`的二进制字符串。
- 如果不只含0和1，返回false
- 只能使用：`01?:*+^$()[]|`
- 这题前面还有两个新手教程题，只需要求模3和模7的。

# 数学模型
首先需要理解：

**如果从左到右逐个字符读进一个`m`进制的字符串，等同于操作一个初值为`0`的变量`x`，每读进一个字符`c`，执行`x=x*m+c`**。

这一理解是此题的精髓之处。你需要想象对一个空字符从右边逐个推入字符直至形成完整的原字符这一过程。

比如对于一个2进制字符串`"1011"`，从左到右逐个字符读入的过程可以写成：
```shell
_ # 初始为0
-> 1 # 0*2+1 = 1
-> 10 # 1*2+0 = 2
-> 101 # 2*2+1 = 5
-> 1011 # 5*2+1 = 11
```
每个箭头可以拆成两步：
1. 将原字符串左移一位，最右侧补0，等同于原字符串`*m`，此处为`*2`
2. 将最右边的位替换为新的字符`c`，由于最后一位是上一步补的0，因此等同于`+c`

题目要求判断是否整除，也就是对于上面的方法得到的`x`，是否有`x mod m == 0`。

而`x mod m`的值，在不断读入字符并执行`x=x*m+c`的过程中，其变化是非常有限的，如果`m`不大，可以直接列表：

|原来的值|读进的字符|新的值|
|:-:|:-:|:-:|
|0|0|0|
|0|1|1|
|1|0|2|
|1|1|0|
|2|0|1|
|2|1|2|

想象一个机器，它里面有个纸板写着个数字，开机的时候是0。你把一个字符串从左到右一个一个喂给他，每喂一个，机器就会把纸板上的数字擦掉写上一个新的，而且**新的值只取决于擦掉前的值和你喂进去的字符**。具体的变化规则就是上面这张表。

如果你去学点计算理论，你会知道这玩意有个专业的名字叫DFA。

现在问题变成，**对于一个上面这样的DFA，初始值状态为0，我们需要判断一个字符序列，在逐个喂给DFA之后，最终的状态是否为0**。

# 从简单情况开始构造正则表达式

方便起见，下文将用三元组表示上面的图中的每一条边，即：
```
(初始状态,新状态,喂进的字符序列)
```

从比较简单的模3入手，有以下6条边：
```
(0,0,0)
(0,1,1)
(1,2,0)
(1,0,1)
(2,1,0)
(2,2,1)
```

画成图是这样的：
![unnamed(2).png](https://s2.loli.net/2023/06/02/8qTy7p4fLM1VXR6.png)

注意：三元组的第三个值并不是简单的字符，而是**字符序列**，意思是喂进这一串字符后，DFA会停在这个新状态。

最终目标是化简这张图，得到这个：
![image.png](https://s2.loli.net/2023/06/05/fj6AGJH7lnbN3dU.png)

求出问号处的字符串即可。

首先观察节点2的这三条边：
```
(2,1,0)
(1,2,0)
(2,2,1)
```
一条进入状态2，一条退出状态2，一条在状态2停留。

我们可以像这样优化掉一条边：
```
(2,1,1*0)
(1,2,01*)
```

停下来想想，不难。可以翻回前面看看三元组第三个值的定义，看看优化后符不符合定义。优化完的图长这样：
![image.png](https://s2.loli.net/2023/06/05/O5aJ3mpyruHBniF.png)

以上是我们需要的第一个基本操作：**去自旋**。

接下来介绍第二个基本操作：**去节点**，我们只需要两个基本操作完成此题。

观察`1->2`和`2->1`的两条边，有没有一种可能，我这样操作：
![image.png](https://s2.loli.net/2023/06/05/B86I3imOXotP7vS.png)

很合理罢，直接把节点2丢掉了。

美观起见，这个正则表达式可以化简一下：
![image.png](https://s2.loli.net/2023/06/05/Du4oQx5ysSzlgeV.png)

有个问题是，去节点操作适用于哪些节点？

答案是**任何不含自己出发指向自己的边的节点都适用**。比如下图中的节点`x`：
![image.png](https://s2.loli.net/2023/06/05/o3gjdbz4nETXeN6.png)
优化后为：
![image.png](https://s2.loli.net/2023/06/05/1TquWBCbRkvzgSK.png)

所以一条粗糙但可行的方案是：**遍历`0`之外的所有节点，对于每个节点，先对它去自旋，再去掉这个节点**。最终一定会剩下唯一一个节点`0`和一条`0->0`的边。

其实还有个问题没考虑到：如果一个节点有多条自己出发指向自己的边怎么办？

其实上面的模3的图，再化简一步就会遇到这个问题：
![image.png](https://s2.loli.net/2023/06/05/noyKTRP5edGz9F7.png)

解决方法也很简单：把两条边用或逻辑`|`连接就好了：
![image.png](https://s2.loli.net/2023/06/05/ZtpqUV4NMg6c8Rm.png)

前后加上`^$`就是最终答案咯：
![image.png](https://s2.loli.net/2023/06/06/Kb1gjXRHLwJnMyQ.png)

# 通用算法
做完了模3的，来试试模7的吧：
![](https://s2.loli.net/2023/06/03/1mHwstxYfeoZLqk.png)

看起来挺哈人，其实思路是一样的：**遍历`0`之外的所有节点，对于每个节点，先对它去自旋，再去掉这个节点**。

不过这题需要求模1~模18的，还是得将化简算法变成代码。

---
# WIP